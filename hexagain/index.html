<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Hexagain</title>
	<style type="text/css">
		html, body {
			background-color: #232220;
			color: #dad6d0;
		}
	</style>
</head>
<body>
	<canvas id="can"></canvas>

	<script type="text/javascript">
		
		/** rnd() random value from 0 to 1
		 *  rnd(n) random from 0 to n
		 *  rnd(n, m) random between n and m
		 *  rnd(array) random element
		 */
		function rnd(a, b) {
			switch (arguments.length) {
				case 0:
					return Math.random();
				case 1:
					if (a instanceof Array) 
						return a[Math.floor(Math.random() * a.length)];
					else 
						return a * Math.random();
				default: // case 2 actually
					return a + (b - a) * Math.random();
			}
		}

		function rndi() {
			return Math.floor(rnd.apply(null, arguments));
		}

	</script>

	<script type="text/javascript">

		function Point(x, y) {
			this.x = x;
			this.y = y;

			this.equal = function(p) {
				return p.x == x && p.y == y;
			};
		}

		function Cell(point, value) {
			this.pos = point;
			this.value = value;
		}

	</script>

	<script type="text/javascript">

		//
		//     world (x y)                this storage (i j) with origin (1 1)
		//
		//            (0 1)                      (0 1)
		//   (-1  0)         (1 1)        (0 0)         (1 2)
		//            (0 0)                      (1 1)
		//   (-1 -1)         (1 0)        (1 0)         (1 2)
		//            (0 -1)                     (2 1)
		//
		function HexStore(extremes, fillfunction) {
			// getWorld(origin) -> 0 0
			this.origin = [0,0];
			this.store = [];

			var self = this;
			var minmax = extremes.reduce(function (current, point) {

				var store = self.getStore(point);
				var i = store[0];
				var j = store[1];

				return current == null
                        ? [i, j, i, j]
                        : [Math.min(current[0], i),
                            Math.min(current[1], j),
                            Math.max(current[2], i),
                            Math.max(current[3], j)];
			}, null);

			var mini = minmax[0];
			var minj = minmax[1];
			var maxi = minmax[2];
			var maxj = minmax[3];

			this.origin = [-mini, -minj];

			var n = this.n = maxi - mini + 1;
			var m = this.m = maxj - minj + 1;

			for (var i = 0; i < n; ++i) {
				var row = [];
				for (var j = 0; j < m; ++j) {
					row.push(fillfunction(new Cell(this.getWorld([i, j]), null)));
				}

				this.store.push(row);
			}
		}

		function halfceil(n) {
			return (n + (n & 1)) >> 1;
		}

		HexStore.prototype.getStore = function(world) {
			var x = world.x;
			var y = world.y;

			var i0 = this.origin[0];
			var j0 = this.origin[1];

			var j = x + j0;
			var i = -y + i0 - halfceil(j0) + halfceil(j);

			return [i, j];
		};

		HexStore.prototype.getWorld = function(store) {
			var i = store[0];
			var j = store[1];

			var i0 = this.origin[0];
			var j0 = this.origin[1];

			var x = j - j0;
			var y = i0 - i - halfceil(j0) + halfceil(j);

			return new Point(x, y);
		};

		HexStore.prototype.each = function(iter) {
			for (var i = 0; i < this.n; ++i) {
				for (var j = 1; j < this.m; j+=2) {
					var val = this.store[i][j];
					if (val != null) {
						iter(new Cell(this.getWorld([i, j]), val));
					}
				}
				
				for (var j = 0; j < this.m; j += 2) {
					var val = this.store[i][j];
					if (val != null) {
						iter(new Cell(this.getWorld([i, j]), val));
					}
				}
			}
		};

		HexStore.prototype.get = function(world) {
			var store = this.getStore(world);
			var i = store[0];
			var j = store[1];

			var coordValid = i >= 0 && i < this.n && j >= 0 && j < this.m;

			return coordValid
				?this.store[i][j]
				: null;
		};

		HexStore.prototype.set = function(world, conv) {
			var store = this.getStore(world);
			var i = store[0];
			var j = store[1];

			var coordValid = i >= 0 && i < this.n && j >= 0 && j < this.m;

			if (coordValid) {
				this.store[i][j] = (conv instanceof Function) ?
					conv(this.store[i][j])
					: conv;
			}
		};

		HexStore.prototype.update = function(iter) {
			var store = [];
			for (var i = 0; i < this.n; ++i) {
				var row = [];
				for (var j = 0; j < this.m; ++j) {
					var val = this.store[i][j];
					if (val != null) {
						var newval = iter(new Cell(this.getWorld([i, j]), val));
						if (newval != null)
							val = newval;
					}
					row.push(val);
				}
				store.push(row);
			}

			this.store = store;
		};

		HexStore.prototype.getAdjacent = function(world) {
			var $ = this;

			function adj(dx, dy) {
				var point = new Point(world.x + dx, world.y + dy);
				var store = $.getStore(point);
				var i = store[0];
				var j = store[1];

				var value = (i >= 0 && i < $.n && j >= 0 && j < $.m)
					? $.store[i][j]
					: null;

				return new Cell(point, value);
			}

			return [
				adj(1, 0),
				adj(1, 1),
				adj(0, 1),
				adj(-1, 0),
				adj(-1, -1),
				adj(0, -1)
			];
		};

	</script>

	<script type="text/javascript">
		function fullscreenCanvas(id) {
			var c = window.document.getElementById(id);
			var ctx = c.getContext('2d');

			ctx.canvas.width = window.innerWidth;
			ctx.canvas.height = window.innerHeight;
			ctx.canvas.style.position = 'absolute';
			ctx.canvas.style.top = 0;
			ctx.canvas.style.left = 0;

			return ctx;
		}

		var ctx = fullscreenCanvas('can');
		var w = ctx.canvas.width;
		var h = ctx.canvas.height;

		var q = 1 / Math.sqrt(3);

		ctx.pathHex = function(h) {
			var dx = q * h / 2;
			var dy = h / 2;

			this.beginPath();
			this.moveTo(2 * dx, 0);
			this.lineTo(dx, -dy);
			this.lineTo(-dx, -dy);
			this.lineTo(-2 * dx, 0);
			this.lineTo(-dx, dy);
			this.lineTo(dx, dy);
			this.closePath();
		};

		ctx.fillHex = function(x, y, h) {
			this.save();
			this.translate(x, y);
			this.pathHex(h);
			this.fill();
			this.restore();
		};
		
		ctx.strokeHex = function (x, y, h) {
			this.save();
			this.translate(x, y);
			this.pathHex(h);
			this.stroke();
			this.restore();
		};

		ctx.translate(ctx.canvas.width / 2, ctx.canvas.height / 2);
	</script>

	<script type="text/javascript">

		/* Hexagonal area with same tiling properties as underlying cells.
		 */
		function SuperCell(x, y, rank) {
			this.x = x;
			this.y = y;
			this.rank = rank;
		}

		SuperCell.prototype.getCorners = function() {
			var r = this.rank;

			return [new Point(2 * r, r - 1),
				new Point(2 * r, r),
				new Point(r, 2 * r),
				new Point(r - 1, 2 * r),
				new Point(-r + 1, r + 1),
				new Point(-r, r),
				new Point(-2 * r, -r),
				new Point(-2 * r, -r - 1),
				new Point(-r - 1, -2 * r),
				new Point(-r, -2 * r),
				new Point(r, -r),
				new Point(r + 1, -r + 1)
			];
		};

		SuperCell.prototype.contains = function(point) {
			var x = point.x - this.x;
			var y = point.y - this.y;

			var a = this.rank * 3 + 1;
			var b = this.rank * 3;

			var leftup = 2 * x + b;
			var top = (x + a) / 2;
			var rightup = b - x;
			var rightdown = 2 * x - a;
			var bottom = (x - b) / 2;
			var leftdown = -x - a;

			return leftup >= y
				&& top >= y
				&& rightup >= y
				&& rightdown <= y
				&& bottom <= y
				&& leftdown <= y;
		};

	</script>

	<script type="text/javascript">
		//
		// add wrapping
		//

		var rank = 15;
		var supercell = new SuperCell(0, 0, rank);
		var extremes = supercell.getCorners();
		var cellsize = 14;

		var bedrock = {};
		var stone = {};
		var raw = {};
		var polished = {};
		var door = {};

		var setInitialValue = function(cell) {
			return supercell.contains(cell.pos) ? { type: stone } : null;
		};

		var store = new HexStore(extremes, setInitialValue);


		function blob(x, y, a, b, c, d) {
			b = b || a;
			c = c || a;
			d = d || c;

			if (a + d - c < 1)
				d = c + 1 - a;

			for (var i = 0; i < b + c - 1; ++i) {
				for (var j = (i > b-1 ? i - b + 1 : 0); j < (i < d ?  a + i: a+d-1); ++j)
					store.set(new Point(x + j, y + i), { type: polished });
			}
		}

		var hw = 3; // half leaf width
		var di = 10; // distance from center
		var le = 2; // leaf length

		blob(di, di, hw, hw, le);//    /
		blob(-(le + di), -(le + di), hw, hw, le);

		blob(di, -(hw - 1), le, hw, hw); //  \
		blob(-(le + di), -(hw - 1), le, hw, hw);

		blob(-(hw-1), di, hw, le, hw); //  |
		blob(-(hw - 1), -(le + di), hw, le, hw);// |

		var cursor = new Point(0, 0);

		function getScreen(world) {
			var s = cellsize;
			var q = .95;

			return new Point(
				q * s * world.x * Math.sqrt(3) / 2,
				q * -s * (world.y - world.x / 2)
			);
		}

		bedrock.color = '#3a3a3a';
		stone.color = 'transparent';
		raw.color =  '#887';
		polished.color = '#555452';
		door.color = '#762';

		var upleft = {};
		var up = {};
		var upright = {};
		var downleft = {};
		var down = {};
		var downright = {};

		var dirs = [up, upleft, downleft, down, downright, upright];

		var brush = stone;
		var oldbrush = brush;


		var seed = 1;
		function random(n) {
			var x = Math.sin(seed++) * 10000;
			return n * (x - Math.floor(x));
		}

		function drawCell(cell) {
			var s = cellsize;
			var screen = getScreen(cell.pos);
			var x = screen.x;
			var y = screen.y;

			var bg = 'transparent';

			if (cell.value != null && cell.value.type != null) {
				bg = cell.value.type.color || 'transparent';
			}

			ctx.fillStyle = bg;

			base = 360 * (Math.sin(x/70) + Math.sin(y/80));

			seed = 1000 + (x + 9.32) * (y + 1.23);

			ctx.fillStyle = bg == 'transparent' ? bg : 'hsl(' + (base + random(40)) + ', ' + (50 + random(50)) + '%,' + (30 + random(40)) + '%)';
			//ctx.fillHex(x, y, s * .8);

			ctx.save();
			ctx.translate(x, y);

			ctx.rotate(-Math.PI / 3);
			store.getAdjacent(cell.pos).forEach(function (adj) {
				if (adj.value != null && adj.value.type == cell.value.type) {

					var q = 1 / Math.sqrt(3);
					var dx = q * s / 2;
					var dy = s / 2;

					ctx.fillRect(-dx * 1.05, dy, 2 * dx * 1.05, -s * .66);
					
					/*
			this.moveTo(2 * dx, 0);
			this.lineTo(dx, -dy);
			this.lineTo(-dx, -dy);
			this.lineTo(-2 * dx, 0);
			this.lineTo(-dx, dy);
			this.lineTo(dx, dy);
					*/


				}
				ctx.rotate(-Math.PI / 3);
			});

			ctx.restore();


		}

		function drawcursor(screen) {
			ctx.fillStyle = 'rgba(255,255,255,.6)';
			ctx.beginPath();
			ctx.arc(screen.x, screen.y, cellsize / 3, 0, 2 * Math.PI);
			ctx.fill();

			ctx.fillStyle = brush.color;
			ctx.beginPath();
			ctx.arc(screen.x, screen.y, cellsize / 3.2, 0, 2 * Math.PI);
			ctx.fill();

			ctx.fillStyle = 'rgba(255,255,255,.6)';
			ctx.beginPath();
			ctx.arc(screen.x, screen.y, cellsize / 4.2, 0, 2 * Math.PI);
			ctx.fill();
		}

		var n = 0;
		var total = 0;

		function draw() {
			var start = (new Date).getTime();

			ctx.clearRect(-ctx.canvas.width, -ctx.canvas.height , 2*ctx.canvas.width, 2*ctx.canvas.height);
			store.each(drawCell);
			
			var screen = getScreen(cursor);
			
			drawcursor(screen);
			var t = ((new Date).getTime() - start);
			++n;
			total += t;
			//console.log(t + 'ms', ((total / n)|0) +'ms avg');
		}



		function steer(dir, cw)
		{
			return dirs[(dirs.indexOf(dir) + (cw ? 1 : -1) + dirs.length) % dirs.length];
		}

		function adj(dir, coord) {
			var x = coord.x;
			var y = coord.y;

			switch (dir) {
				case up:
					++y;
					break;
				case down:
					--y;
					break;
				case upleft:
					--x;
					break;
				case downright:
					++x;
					break;
				case upright:
					++x;
					++y;
					break;
				case downleft:
					--x;
					--y;
					break;
			}

			return new Point(x, y);
		}

		var maxStraight = 6;

		//ctx.scale(1, .86);


		// todo: primitives (lines and shapes)
		// randomized branching
		// adjacency-aware cell rendering

		var start = new Point(0,0);
		store.set(start, { type: polished });

		var heads1 = [
			// current head, direction, since turn, backtrack stack
			[start, up, rndi(maxStraight/2), []],
			[start, downleft, rndi(maxStraight / 2), []],
			[start, downright, rndi(maxStraight / 2), []]
		];
		
		var headses = [heads1];

		function tanh(x) {
			var exp = Math.exp;
			return (exp(2 * x) - 1) / (exp(2 * x) + 1);
		}

		function grow() {

			var draw = false;
			var more = false;

			headses = headses.map(function (heads) {
				heads = heads.map(function (head) {
					var c = head[0];
					var d = head[1];
					var t = head[2];
					var q = head[3];

					var x = t / maxStraight;
					var splitpos = (1 - tanh(Math.PI - 2 * Math.PI * Math.sin(x) * x)) / 2;

					if (rnd() < splitpos) {
						t = 0;
						d = steer(d, (rndi(100) % 2) == 0);
					}

					var dir = d;
					var cw = (rndi(100) % 2) == 0;
					do {
						var nextp = adj(d, c);
						var xx = store.getAdjacent(c);
						next = store.get(nextp);

						if (next != null && next.type == stone) {
							var parentAdjacentFound = false;

							function isValidNewHallwayAdjacent(cell) {

								if (cell.value != null) {
									var cellSolid = cell.value.type == stone;
									var isParent = cell.pos.equal(c);
									var oneOfParentsAdjacent = !parentAdjacentFound && xx.map(function (cell) { return cell.pos }).some(cell.pos.equal);
									parentAdjacentFound |= oneOfParentsAdjacent

									return cellSolid || isParent || oneOfParentsAdjacent;
								}

								return false; // cell missing
							}

							var validNew = store.getAdjacent(nextp).every(isValidNewHallwayAdjacent);

							if (validNew) {
								draw = true;
								q.push(c);
								return [nextp, d,t+1, q];
							}
						}

						d = steer(d, cw);
					} while (dir != d);


					var next = q.pop();
					if (next) return [next, d, t + 1, q];

				}).filter(function (o) { return !!o });

				heads.forEach(function (head) { store.set(head[0], { type: polished }) });

				more |= heads.length > 0;

				return heads;
			});

			return draw || (headses.length == 0) ? more : (more | grow());
		}

		function frame() {
			var more = grow();
			draw();

			if (more)
				window.setTimeout(frame, 10);
		}

		frame();

		//while (grow());
		//draw();

		window.addEventListener('keydown', function (e) {
			
			var left = {};
			var right = {};
			var toggle = {};

			var brush1 = {};
			var brush2 = {};
			var brush3 = {};
			var brush4 = {};
			var brush5 = {};

			function key2action(event) {
				var map = {
					103: upleft,
					104: up,
					105: upright,
					100: downleft,
					101: down,
					102: downright,
					97: left,
					99: right,
					32: toggle,
					49: brush1,
					50: brush2,
					51: brush3,
					52: brush4,
					53: brush5,
				};

				return map[event.which];
			}

			var x = cursor.x;
			var y = cursor.y;

			switch (key2action(e)) {
			case up:
				++y;
				break;
			case down:
				--y;
				break;
			case upleft:
				--x;
				break;
			case downright:
				++x;
				break;
			case upright:
				++x;
				++y;
				break;
			case downleft:
				--x;
				--y;
				break;
			case left:
				--x;
				y -= x & 1;
				break;
			case right:
				y += x & 1;
				++x;
				break;
				case brush1:
					oldbrush = brush;
					brush = stone;
					break;
				case brush2:
					oldbrush = brush;
					brush = raw;
					break;
				case brush3:
					oldbrush = brush;
					brush = polished;
					break;
				case brush4:
					oldbrush = brush;
					brush = door;
					break;
			case toggle:
				store.set(cursor, function (old) {
					return ("type" in old && old.type == brush)
						? { type: oldbrush }
						: { type: brush };
				});
				break;
			}

			cursor = new Point(x, y);
			draw();

		}, false);
	</script>
</body>
</html>

