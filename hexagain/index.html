<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>Hexagain</title>
    <style type="text/css">
        html, body {
            background-color: #232220;
            color: #dad6d0;
        }
    </style>
</head>
<body>
    <canvas id="can"></canvas>

    <!-- random -->
    <script type="text/javascript">

        /** rnd() random value from 0 to 1
		 *  rnd(n) random from 0 to n
		 *  rnd(n, m) random between n and m
		 *  rnd(array) random element
		 */
        function rnd(a, b) {
            switch (arguments.length) {
                case 0:
                    return Math.random();
                case 1:
                    if (a instanceof Array)
                        return a[Math.floor(Math.random() * a.length)];
                    else
                        return a * Math.random();
                default: // case 2 actually
                    return a + (b - a) * Math.random();
            }
        }

        function rndi() {
            return Math.floor(rnd.apply(null, arguments));
        }

    </script>

    <!-- Point -->
    <script type="text/javascript">

        function Point(x, y) {
            this.x = x;
            this.y = y;
        }

        Point.prototype.toString = function () { return this.x + ',' + this.y }

        Point.prototype.equal = function (p) {
            return this.x == p.x && this.y == p.y;
        }

        Point.prototype.times = function (n) {
            return new Point(this.x * n, this.y * n);
        }

        Point.prototype.add = function (dx, dy) {
            return new Point(this.x + dx, this.y + dy);
        }

        Point.prototype.plus = function (p) {
            return new Point(this.x + p.x, this.y + p.y);
        }

    </script>

    <!-- Hexstore -->
    <script type="text/javascript">

        var downright = {};
        var upright = {}
        var up = {};
        var upleft = {};
        var downleft = {};
        var down = {};

        var MakeHexStore = (function () {

            function halfceil(n) {
                // changing "-" to "+" will change array storage to other configuration
                return (n - (n & 1)) >> 1;
            }

            function getStoreFun(ox, oy) {

                ox = ox || 0;
                oy = oy || 0;

                // return world to index coordinate conversion function give an origin (getWorld(origin) -> 0 0).
                return function (world) {

                    var x = world.x;
                    var y = world.y;

                    var j = x + oy;
                    var i = -y + ox - halfceil(oy) + halfceil(j);

                    return [i, j];
                }
            }

            function getWorldFun(ox, oy) {

                ox = ox || 0;
                oy = oy || 0;

                return function (i, j) {
                    var x = j - oy;
                    var y = ox - i - halfceil(oy) + halfceil(j);

                    return new Point(x, y);
                }
            };

            function findStoreParameters(extremes) {
                var getStore = getStoreFun();

                var minmax = extremes.reduce(function (current, point) {

                    var store = getStore(point);
                    var i = store[0];
                    var j = store[1];

                    return current == null
							? [i, j, i, j]
							: [Math.min(current[0], i),
								Math.min(current[1], j),
								Math.max(current[2], i),
								Math.max(current[3], j)];
                }, null);

                var mini = minmax[0];
                var minj = minmax[1];
                var maxi = minmax[2];
                var maxj = minmax[3];

                // x, y
                var origin = [-mini, -minj];

                // max i, max j
                var dim = [maxi - mini + 1, maxj - minj + 1];

                return [origin, dim];
            }

            function copy(data, valueClass) {

                var n = data.length;
                var m = data[0].length;

                var cpy = [];

                for (var i = 0; i < n; ++i) {
                    var row = [];
                    for (var j = 0; j < m; ++j) {
                        var val = data[i][j];
                        row.push(val == null ? null : valueClass(val));
                    }
                    cpy.push(row);
                }

                return cpy;
            }

            function getter(i, j, data) {
                return (i >= 0 && j >= 0 && i < data.length && j < data[0].length && data[i][j] != null)
					? function () { return data[i][j] }
					: function () { return null };
            }

            function setter(i, j, data) {
                return (i >= 0 && j >= 0 && i < data.length && j < data[0].length && data[i][j] != null)
					? function (v) { data[i][j] = v }
					: function (v) { };
            }

            function adjacentFunc(i, j, pos, data, ro) {
                // dir dx dy
                var dirs = [
					[downright, 1, 0],
					[upright, 1, 1],
					[up, 0, 1],
					[upleft, -1, 0],
					[downleft, -1, -1],
					[down, 0, -1]
                ];

                return function () {
                    return dirs.map(function (d) {
                        var dx = d[1];
                        var dy = d[2];

                        var j1 = j + dy;

                        // TODO: algo

                        var map = [];
                        map[0] = [];
                        map[1] = [];

                        map[0][-1] = [];
                        map[0][0] = [];
                        map[0][1] = [];

                        map[1][-1] = [];
                        map[1][0] = [];
                        map[1][1] = [];

                        map[0][-1][-1] = 0;
                        map[0][-1][0] = -1;

                        map[0][0][-1] = 1;
                        map[0][0][1] = -1;

                        map[0][1][0] = 0;
                        map[0][1][1] = -1;

                        map[1][-1][-1] = 1;
                        map[1][-1][0] = 0;

                        map[1][0][-1] = -1;
                        map[1][0][1] = -1;

                        map[1][1][0] = 1;
                        map[1][1][1] = 0;

                        var i1 = i + map[j % 2][dx][dy];

                        return [d[0], MakeCell(i1, j1, pos.add(dx, dy), data, ro)];
                    })
                };
            };

            function MakeCell(i, j, pos, data, ro) {
                return new Cell(pos, getter(i, j, data), ro ? null : setter(i, j, data), adjacentFunc(i, j, pos, data, ro));
            }

            function MakeHexStoreInternal(data, valueClass, origin) {

                var getStore = getStoreFun(origin[0], origin[1]);
                var getWorld = getWorldFun(origin[0], origin[1]);

                var oldStore = { adminHandle: {}, userHandle: {} };

                oldStore.userHandle.nextGen = function (cellCellStoreStoreFunc) {

                    var newData = copy(data, valueClass);
                    var newStore = MakeHexStoreInternal(newData, valueClass, origin);

                    var n = data.length;
                    var m = data[0].length;

                    for (var i = 0; i < n; ++i) {
                        for (var j = 0; j < m; ++j) {
                            var pos = getWorld(i, j);
                            var oldCell = MakeCell(i, j, pos, data, true);
                            var newCell = MakeCell(i, j, pos, newData, false);

                            cellCellStoreStoreFunc(oldCell, newCell, oldStore.userHandle, newStore.userHandle)
                        }
                    }

                    return newStore.userHandle;
                }

                oldStore.userHandle.set = function (world, conv) {

                    var store = getStore(world);
                    var i = store[0];
                    var j = store[1];

                    var coordValid = i >= 0 && j >= 0 && i < data.length && j < data[0].length;

                    if (coordValid) {
                        data[i][j] = (conv instanceof Function)
							? conv(data[i][j])
							: conv;
                    }
                }

                oldStore.userHandle.forEach = function (iter) {
                    var n = data.length;
                    var m = data[0].length;

                    for (var i = 0; i < n; ++i) {
                        for (var j = 1; j < m; j += 2) {
                            var val = data[i][j];
                            if (val != null) {
                                iter(MakeCell(i, j, getWorld(i, j), data, true));
                            }
                        }

                        for (var j = 0; j < m; j += 2) {
                            var val = data[i][j];
                            if (val != null) {
                                iter(MakeCell(i, j, getWorld(i, j), data, true));
                            }
                        }
                    }
                };


                return oldStore;
            }

            function Cell(pos, get, set, adjacent) {
                this.pos = pos;
                this.get = get;
                this.set = set;
                this.adjacent = adjacent;
            }

            //
            //     world (x y)                this storage (i j) with origin (1 1)
            //                                (0 0)\       /(0 2)
            //            (0 1)                     \(0 1)/
            //   (-1  0)         (1 1)        (1 0)\       /(1 2)
            //            (0 0)                     \(1 1)/
            //   (-1 -1)         (1 0)        (2 0)\       /(2 2)
            //            (0 -1)                    \(2 1)/
            //
            function MakeHexStore(extremes, valueClass) {
                // Value class is expected to have a point constructor and a copy constructor

                var params = findStoreParameters(extremes);

                var origin = params[0];
                var dim = params[1];

                var getWorld = getWorldFun(origin[0], origin[1]);

                var n = dim[0];
                var m = dim[1];

                var data = [];

                for (var i = 0; i < n; ++i) {
                    var row = [];
                    for (var j = 0; j < m; ++j) {
                        var value = valueClass(getWorld(i, j));

                        row.push(value);
                    }

                    data.push(row);
                }

                return MakeHexStoreInternal(data, valueClass, origin).userHandle;
            }

            return MakeHexStore;
        })();

    </script>

    <!-- Fullscreen canvas and drawhex -->
    <script type="text/javascript">
        function fullscreenCanvas(id) {
            var c = window.document.getElementById(id);
            var ctx = c.getContext('2d');

            ctx.canvas.width = window.innerWidth;
            ctx.canvas.height = window.innerHeight;
            ctx.canvas.style.position = 'absolute';
            ctx.canvas.style.top = 0;
            ctx.canvas.style.left = 0;

            return ctx;
        }

        var ctx = fullscreenCanvas('can');
        var w = ctx.canvas.width;
        var h = ctx.canvas.height;

        var q = 1 / Math.sqrt(3);

        ctx.pathHex = function (h) {
            var dx = q * h / 2;
            var dy = h / 2;

            this.beginPath();
            this.moveTo(2 * dx, 0);
            this.lineTo(dx, -dy);
            this.lineTo(-dx, -dy);
            this.lineTo(-2 * dx, 0);
            this.lineTo(-dx, dy);
            this.lineTo(dx, dy);
            this.closePath();
        };

        ctx.fillHex = function (x, y, h) {
            this.save();
            this.translate(x, y);
            this.pathHex(h);
            this.fill();
            this.restore();
        };

        ctx.strokeHex = function (x, y, h) {
            this.save();
            this.translate(x, y);
            this.pathHex(h);
            this.stroke();
            this.restore();
        };

        ctx.translate(ctx.canvas.width / 2, ctx.canvas.height / 2);
    </script>

    <!-- Supercell -->
    <script type="text/javascript">
        /* Hexagonal area with same tiling properties as underlying cells.
		 */
        function SuperCell(x, y, rank) {
            this.x = x;
            this.y = y;
            this.rank = rank;
        }

        SuperCell.prototype.getCorners = function () {
            var r = this.rank;

            return [new Point(2 * r, r - 1),
				new Point(2 * r, r),
				new Point(r, 2 * r),
				new Point(r - 1, 2 * r),
				new Point(-r + 1, r + 1),
				new Point(-r, r),
				new Point(-2 * r, -r),
				new Point(-2 * r, -r - 1),
				new Point(-r - 1, -2 * r),
				new Point(-r, -2 * r),
				new Point(r, -r),
				new Point(r + 1, -r + 1)
            ];
        };

        SuperCell.prototype.contains = function (point) {
            var x = point.x - this.x;
            var y = point.y - this.y;

            var a = this.rank * 3 + 1;
            var b = this.rank * 3;

            var leftup = 2 * x + b;
            var top = (x + a) / 2;
            var rightup = b - x;
            var rightdown = 2 * x - a;
            var bottom = (x - b) / 2;
            var leftdown = -x - a;

            return leftup >= y
				&& top >= y
				&& rightup >= y
				&& rightdown <= y
				&& bottom <= y
				&& leftdown <= y;
        };

    </script>

    <script type="text/javascript">
        //
        // TODO:
        //	get all hexes within specified hex-distance - see pill
        //	calculate FOV (maybe by extending line algo)
        //		calculate illumination (apply light from several sources plus player FOV)
        //	add wrapping
        //

        function Adjustable() {
            this.k = 20;
            this.min = 0;
            this.max = .1;

            this.currentmin = null;
            this.currentmax = null;
            this.range = null;
        }

        Adjustable.prototype.scale = function (v) {
            this.max = Math.max(this.max, v);
            this.min = Math.min(this.min, v);

            if (this.currentmin == null)
                this.currentmin = this.min;

            if (this.currentmax == null)
                this.currentmax = this.max;

            this.range = this.currentmax - this.currentmin;

            return this.currentmax == this.currentmin ? 1 : (v - this.currentmin) / this.range;
        }

        Adjustable.prototype.adjust = function () {
            this.currentmax += (this.max - this.currentmax) / this.k;
            this.currentmin += (this.min - this.currentmin) / this.k;
        }

        var rank = 10;
        var supercell = new SuperCell(0, 0, rank);
        var extremes = supercell.getCorners();
        var cellsize = 14;

        var bedrock = {};
        var stone = {};
        var raw = {};
        var polished = {};
        var door = {};
        var wall = {};
        var maxlevel = 24;

        function cutoff(t) {
            return t * t * t * (t * 3 * (2 * t - 5) + 10);
        }

        function hexdist(p1, p2) {
            var dx = p1.x - p2.x;
            var dy = p1.y - p2.y;

            var sx = dx >= 0 ? 1 : -1;
            var sy = dy >= 0 ? 1 : -1;

            dx = dx < 0 ? -dx : dx;
            dy = dy < 0 ? -dy : dy;

            return sx == sy
				? (dx > dy ? dx : dy)
				: (dx + dy);
        }

        function worddist(p1, p2) {
            var sq32 = Math.sqrt(3) / 2;

            var x1 = p1.x * sq32;
            var x2 = p2.x * sq32;
            var y1 = -(p1.y - p1.x / 2);
            var y2 = -(p2.y - p2.x / 2);

            var dx = x2 - x1;
            var dy = y2 - y1;

            return Math.sqrt(dx * dx + dy * dy);
        }

        var maxdist = rank / 3 | 0;
        var maxamount = 40;

        // TODO: merge pill and blob for pill is just a blob special case.
        function Pill(w, h) {
            var h = Math.floor(h / 2);
            var w = Math.floor(w / 2);

            this.extremes = [
				new Point(0, h),
				new Point(0, -h),
				new Point(w, h),
				new Point(-w, -h),
				new Point(-w, h - w),
				new Point(w, -h + w)
            ];

            this.contains = function (pos) {
                var x = pos.x;
                var y = pos.y;

                return y <= h && y >= -h && x <= w && x >= -w && y <= x + h && y >= x - h
            }
        }

        function blob(x, y, a, b, c, d) {
            b = b || a;
            c = c || a;
            d = d || c;

            if (a + d - c < 1)
                d = c + 1 - a;

            for (var i = 0; i < b + c - 1; ++i) {
                for (var j = (i > b - 1 ? i - b + 1 : 0) ; j < (i < d ? a + i : a + d - 1) ; ++j)
                    store.set(new Point(x + j, y + i), { type: polished });
            }
        }

        function line(p1, p2) {
            var dx = p2.x - p1.x;
            var dy = 2 * (p2.y - p1.y) - dx;

            var sx = dx >= 0 ? 1 : -1;
            var sy = dy >= 0 ? 1 : -1;

            dx = Math.abs(dx);
            dy = Math.abs(dy);

            var alwaysDy = dy >= dx;

            var x = p1.x;
            var y = p1.y;

            var points = [new Point(x, y)];

            var e = 0;
            var n = 0, limit = 200;

            while (1) {
                if (alwaysDy) {
                    e += dx;
                    if (3 * e >= dy) {
                        x += sx;
                        y += (sy == sx) ? sy : 0;
                        e -= dy;
                    } else {
                        y += sy;
                        e += dx;
                    }
                } else {
                    e += dy;
                    if (e > 0) {
                        y += (sy == sx) ? sy : 0;
                        e -= dx;
                    } else {
                        y -= (sx == sy) ? 0 : sy;
                        e += dx;
                    }
                    x += sx;
                }

                points.push(new Point(x, y));

                if (p2.x == x && p2.y == y)
                    break;
            }

            return points;
        }

        //var hw = 3; // half leaf width
        //var di = 10; // distance from center
        //var le = 2; // leaf length

        //blob(di, di, hw, hw, le);//    /
        //blob(-(le + di), -(le + di), hw, hw, le);

        //blob(di, -(hw - 1), le, hw, hw); //  \
        //blob(-(le + di), -(hw - 1), le, hw, hw);

        //blob(-(hw - 1), di, hw, le, hw); //  |
        //blob(-(hw - 1), -(le + di), hw, le, hw);// |

        var cursor = new Point(0, 0);

        var sq32 = Math.sqrt(3) / 2;

        function getScreen(world) {
            var s = cellsize;
            var q = .95;

            return new Point(
				q * s * world.x * sq32,
				q * -s * (world.y - world.x / 2)
			);
        }

        var dirs = [up, upleft, downleft, down, downright, upright];
        var water = {};

        function CellValue(type, value) {
            this.type = type;
            this.value = value;
        }

        function MakeCellValue(arg) {

            if (arg instanceof Point && supercell.contains(arg)) {

                var sx = arg.x >= 0 ? 1 : -1;
                var sy = arg.y >= 0 ? 1 : -1;

                var x = Math.abs(arg.x);
                var y = Math.abs(arg.y);

                var dist;
                if (sx == sy)
                    dist = x >= y ? x : y;
                else
                    dist = x + y;

                dist = hexdist(new Point(0, 0), arg);
                dist = worddist(new Point(0, 0), arg);

                var amount = dist >= maxdist ? 0 : (cutoff(1 - dist / maxdist) * maxamount) | 0;

                return new CellValue(water, amount);
            }
            else if (arg instanceof CellValue) {
                return new CellValue(arg.type, arg.value);
            }

            return null;
        }

        var store = new MakeHexStore(supercell.getCorners(), MakeCellValue);

        line(new Point(1, -maxdist - 1), new Point(maxdist + 1, -1))
				.forEach(function (p) {
				    store.set(p, { type: wall });
				});

        var lastTime = (new Date()).getTime();

        var maxamount = new Adjustable();

        function draw(store) {

            function cellColor(cell) {
                var val = cell.get();

                if (val != null && val instanceof CellValue && val.type == water) {
                    var a = maxamount.scale(val.value);

                    return a == 0
						? (((cell.pos.x % 6) == 0 && (cell.pos.y % 6) == 0) ? 'hsl(47, 97%, 70%)' : 'hsl(47, 97%, 73%)')
						: 'hsl(220, ' + (10 + 90 * a) + '%, ' + (50 - 40 * a) + '%)';
                }

                return 'transparent';
            }

            function drawCell(cell) {
                var s = cellsize;
                var screen = getScreen(cell.pos);
                var x = screen.x;
                var y = screen.y;

                ctx.fillStyle = cellColor(cell);
                ctx.fillHex(x, y, s);
            }

            ctx.clearRect(-ctx.canvas.width / 2, -ctx.canvas.height / 2, ctx.canvas.width, ctx.canvas.height);
            store.forEach(drawCell);

            maxamount.adjust();
        }

        function tick(delta) {

            function watercell(cell) {
                var val = cell.get();
                return val != null && val instanceof CellValue && val.type == water;
            }

            function wateradj(adj) {
                return watercell(adj[1]);
            }

            function match(dir, adjes) {
                var i = -1, n = adjes.length;

                while (++i < n)
                    if (adjes[i][0] == dir)
                        return adjes[i][1];

                return null;
            }

            var opposite = [];

            opposite[downright] = upleft;
            opposite[upright] = downleft;
            opposite[up] = down;
            opposite[upleft] = downleft;
            opposite[downleft] = upright;
            opposite[down] = up;

            return store = store.nextGen(function (oldCell, newCell, oldStore, newStore) {

                if (watercell(oldCell)) {

                    var val = oldCell.get().value;
                    var v0 = val;

                    var oldadj = oldCell.adjacent();
                    var newadj = newCell.adjacent();

                    function score(adj) {
                        // the bigger the better
                        var grad = v0 - adj[1].get().value;

                        var opps = match(opposite[adj[0]], oldadj);

                        var opgrad = watercell(opps) ? (opps.get().value - v0) : 0;

                        return grad + opps;
                    }

                    function byadjvalue(adj1, adj2) {
                        // reverse order
                        return score(adj2) - score(adj1);
                    }

                    oldadj.filter(wateradj)
						.sort(byadjvalue)
						.forEach(function (adj) {

						    var newcell = match(adj[0], newadj);

						    if (newcell != null) {
						        var newval = newcell.get();

						        if (val > 1 && newval.value < val) {
						            --val;
						            ++newval.value;
						        }
						    }
						});

                    newCell.get().value -= v0 - val;
                }
            });
        }


        var frames = 80;
        function render() {
            var newTime = (new Date()).getTime();
            var delta = newTime - lastTime;
            lastTime = newTime;

            if (frames < 40)
                tick(delta);


            draw(store);

            var time = (new Date()).getTime();

            if (--frames > 0)
              //  window.setTimeout(render, 1000);
            window.requestAnimationFrame(render);
        }

        render();

    </script>
    <!-- user input -->
    <script type="text/javascript">

        function InputManager(mapping) {
            var $ = this;
            this.action = null;
            this.handler = function (event) { $.action = mapping[event.which] };

            window.addEventListener('keydown', this.handler, false);
        }

    </script>

</body>
</html>
