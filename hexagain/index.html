<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Hexagain</title>
	<style type="text/css">
		html, body {
			background-color: #232220;
			color: #dad6d0;
		}
	</style>
</head>
<body>
	<canvas id="can"></canvas>
	
	<!-- random -->
	<script type="text/javascript">

		/** rnd() random value from 0 to 1
		 *  rnd(n) random from 0 to n
		 *  rnd(n, m) random between n and m
		 *  rnd(array) random element
		 */
		function rnd(a, b) {
			switch (arguments.length) {
				case 0:
					return Math.random();
				case 1:
					if (a instanceof Array)
						return a[Math.floor(Math.random() * a.length)];
					else
						return a * Math.random();
				default: // case 2 actually
					return a + (b - a) * Math.random();
			}
		}

		function rndi() {
			return Math.floor(rnd.apply(null, arguments));
		}

	</script>

	<!-- Point and cell -->
	<script type="text/javascript">

		function Point(x, y) {
			this.x = x;
			this.y = y;

			this.equal = function (p) {
				return p.x == x && p.y == y;
			};
		}

		Point.prototype.toString = function () { return this.x + ',' + this.y}

		Point.prototype.times = function (n) {
			return new Point(this.x * n, this.y * n);
		}

		Point.prototype.plus = function (p) {
			return new Point(this.x + p.x, this.y + p.y);
		}


		function Cell(point, value) {
			this.pos = point;
			this.value = value;
		}

	</script>

	<!-- Hexstore -->
	<script type="text/javascript">

		//
		//     world (x y)                this storage (i j) with origin (1 1)
		//                                (0 0)\       /(0 2)
		//            (0 1)                     \(0 1)/
		//   (-1  0)         (1 1)        (1 0)\       /(1 2)
		//            (0 0)                     \(1 1)/
		//   (-1 -1)         (1 0)        (2 0)\       /(2 2)
		//            (0 -1)                    \(2 1)/
		//
		function HexStore(extremes, fillfunction) {
			// getWorld(origin) -> 0 0
			this.origin = [0, 0];
			this.store = [];

			var self = this;
			var minmax = extremes.reduce(function (current, point) {

				var store = self.getStore(point);
				var i = store[0];
				var j = store[1];

				return current == null
                        ? [i, j, i, j]
                        : [Math.min(current[0], i),
                            Math.min(current[1], j),
                            Math.max(current[2], i),
                            Math.max(current[3], j)];
			}, null);

			var mini = minmax[0];
			var minj = minmax[1];
			var maxi = minmax[2];
			var maxj = minmax[3];

			this.origin = [-mini, -minj];

			var n = this.n = maxi - mini + 1;
			var m = this.m = maxj - minj + 1;

			for (var i = 0; i < n; ++i) {
				var row = [];
				for (var j = 0; j < m; ++j) {
					row.push(fillfunction(new Cell(this.getWorld([i, j]), null)));
				}

				this.store.push(row);
			}
		}

		function halfceil(n) {
			// changing "-" to "+" will change array storage to other configuration
			return (n - (n & 1)) >> 1;
		}

		HexStore.prototype.getStore = function (world) {
			var x = world.x;
			var y = world.y;

			var i0 = this.origin[0];
			var j0 = this.origin[1];

			var j = x + j0;
			var i = -y + i0 - halfceil(j0) + halfceil(j);

			return [i, j];
		};

		HexStore.prototype.getWorld = function (store) {
			var i = store[0];
			var j = store[1];

			var i0 = this.origin[0];
			var j0 = this.origin[1];

			var x = j - j0;
			var y = i0 - i - halfceil(j0) + halfceil(j);

			return new Point(x, y);
		};

		HexStore.prototype.each = function (iter) {
			for (var i = 0; i < this.n; ++i) {
				for (var j = 1; j < this.m; j += 2) {
					var val = this.store[i][j];
					if (val != null) {
						iter(new Cell(this.getWorld([i, j]), val));
					}
				}

				for (var j = 0; j < this.m; j += 2) {
					var val = this.store[i][j];
					if (val != null) {
						iter(new Cell(this.getWorld([i, j]), val));
					}
				}
			}
		};

		HexStore.prototype.get = function (world) {
			var store = this.getStore(world);
			var i = store[0];
			var j = store[1];

			var coordValid = i >= 0 && i < this.n && j >= 0 && j < this.m;

			return coordValid
				? this.store[i][j]
				: null;
		};

		HexStore.prototype.set = function (world, conv) {
			var store = this.getStore(world);
			var i = store[0];
			var j = store[1];

			var coordValid = i >= 0 && i < this.n && j >= 0 && j < this.m;

			if (coordValid) {
				this.store[i][j] = (conv instanceof Function) ?
					conv(this.store[i][j])
					: conv;
			}
		};

		HexStore.prototype.update = function (iter) {
			var store = [];
			for (var i = 0; i < this.n; ++i) {
				var row = [];
				for (var j = 0; j < this.m; ++j) {
					var val = this.store[i][j];
					if (val != null) {
						var newval = iter(new Cell(this.getWorld([i, j]), val));
						if (newval != null)
							val = newval;
					}
					row.push(val);
				}
				store.push(row);
			}

			this.store = store;
		};

		HexStore.prototype.getAdjacent = function (world) {
			var $ = this;

			function adj(dx, dy) {
				var point = new Point(world.x + dx, world.y + dy);
				var store = $.getStore(point);
				var i = store[0];
				var j = store[1];

				var value = (i >= 0 && i < $.n && j >= 0 && j < $.m)
					? $.store[i][j]
					: null;

				return new Cell(point, value);
			}

			return [
				adj(1, 0),
				adj(1, 1),
				adj(0, 1),
				adj(-1, 0),
				adj(-1, -1),
				adj(0, -1)
			];
		};

	</script>

	<!-- Fullscreen canvas -->
	<script type="text/javascript">
		function fullscreenCanvas(id) {
			var c = window.document.getElementById(id);
			var ctx = c.getContext('2d');

			ctx.canvas.width = window.innerWidth;
			ctx.canvas.height = window.innerHeight;
			ctx.canvas.style.position = 'absolute';
			ctx.canvas.style.top = 0;
			ctx.canvas.style.left = 0;

			return ctx;
		}

		var ctx = fullscreenCanvas('can');
		var w = ctx.canvas.width;
		var h = ctx.canvas.height;

		var q = 1 / Math.sqrt(3);

		ctx.pathHex = function (h) {
			var dx = q * h / 2;
			var dy = h / 2;

			this.beginPath();
			this.moveTo(2 * dx, 0);
			this.lineTo(dx, -dy);
			this.lineTo(-dx, -dy);
			this.lineTo(-2 * dx, 0);
			this.lineTo(-dx, dy);
			this.lineTo(dx, dy);
			this.closePath();
		};

		ctx.fillHex = function (x, y, h) {
			this.save();
			this.translate(x, y);
			this.pathHex(h);
			this.fill();
			this.restore();
		};

		ctx.strokeHex = function (x, y, h) {
			this.save();
			this.translate(x, y);
			this.pathHex(h);
			this.stroke();
			this.restore();
		};

		ctx.translate(ctx.canvas.width / 2, ctx.canvas.height / 2);
	</script>

	<!-- Supercell -->
	<script type="text/javascript">

		/* Hexagonal area with same tiling properties as underlying cells.
		 */
		function SuperCell(x, y, rank) {
			this.x = x;
			this.y = y;
			this.rank = rank;
		}

		SuperCell.prototype.getCorners = function () {
			var r = this.rank;

			return [new Point(2 * r, r - 1),
				new Point(2 * r, r),
				new Point(r, 2 * r),
				new Point(r - 1, 2 * r),
				new Point(-r + 1, r + 1),
				new Point(-r, r),
				new Point(-2 * r, -r),
				new Point(-2 * r, -r - 1),
				new Point(-r - 1, -2 * r),
				new Point(-r, -2 * r),
				new Point(r, -r),
				new Point(r + 1, -r + 1)
			];
		};

		SuperCell.prototype.contains = function (point) {
			var x = point.x - this.x;
			var y = point.y - this.y;

			var a = this.rank * 3 + 1;
			var b = this.rank * 3;

			var leftup = 2 * x + b;
			var top = (x + a) / 2;
			var rightup = b - x;
			var rightdown = 2 * x - a;
			var bottom = (x - b) / 2;
			var leftdown = -x - a;

			return leftup >= y
				&& top >= y
				&& rightup >= y
				&& rightdown <= y
				&& bottom <= y
				&& leftdown <= y;
		};

	</script>

	<script type="text/javascript">
		//
		// TODO:
		//	get all hexes within specified hex-distance - see pill
		//	calculate FOV (maybe by extending line algo)
		//		calculate illumination (apply light from several sources plus player FOV)
		//	add wrapping
		//

		var rank = 15;
		var supercell = new SuperCell(0, 0, rank);
		var extremes = supercell.getCorners();
		var cellsize = 14;

		var bedrock = {};
		var stone = {};
		var raw = {};
		var polished = {};
		var door = {};
		var maxlevel = 24;

		var setInitialValue = function (cell) {
			
			var alwaysDy = Math.abs(2*cell.pos.y-cell.pos.x) >= Math.abs(cell.pos.x);

			return supercell.contains(cell.pos) ? { type: stone, level: (alwaysDy ? 0 : .5)*maxlevel + rndi(.5* maxlevel) } : null;
		};

		function Pill(w, h) {
			var h = Math.floor(h / 2);
			var w = Math.floor(w / 2);

			this.extremes = [
				new Point(0, h),
				new Point(0, -h),
				new Point(w, h),
				new Point(-w, -h),
				new Point(-w, h - w),
				new Point(w, -h + w)
			];

			this.contains = function (pos) {
				var x = pos.x;
				var y = pos.y;

				return y <= h && y >= -h && x <= w && x >= -w && y <= x + h && y >= x - h
			}
		}

		function blob(x, y, a, b, c, d) {
				b = b || a;
				c = c || a;
				d = d || c;

				if (a + d - c < 1)
					d = c + 1 - a;

				for (var i = 0; i < b + c - 1; ++i) {
					for (var j = (i > b - 1 ? i - b + 1 : 0) ; j < (i < d ? a + i : a + d - 1) ; ++j)
						store.set(new Point(x + j, y + i), { type: polished });
				}
			}

			function sign(a) {
				return a < 0 ? -1 : 1;
			}

			function line(p1, p2) {			
				var dx = p2.x - p1.x;
				var dy = 2 * (p2.y - p1.y) - dx;

				var sx = dx >= 0 ? 1 : -1;
				var sy = dy >= 0 ? 1 : -1;

				dx = Math.abs(dx);
				dy = Math.abs(dy);

				var alwaysDy = dy >= dx;

				var x = p1.x;
				var y = p1.y;

				var points = [new Point(x, y)];

				var e = 0;
				var n = 0, limit = 200;
			
				while (1) {
					if (alwaysDy) {
						e += dx;
						if (3 * e >= dy) {
							x += sx;
							y += (sy == sx) ? sy : 0;
							e -= dy;
						} else {
							y += sy;
							e += dx;
						}
					} else {
						e += dy;
						if (e > 0) {
							y += (sy == sx) ? sy : 0;
							e -= dx;
						} else {
							y -= (sx == sy) ? 0 : sy;
							e += dx;
						}
						x += sx;
					}

					points.push(new Point(x, y));

					if (++n > limit) {
						console.log('error');
						break;
					}
					if(p2.x==x && p2.y==y)
						break;
				}
				
				return points;
			}

			//var hw = 3; // half leaf width
			//var di = 10; // distance from center
			//var le = 2; // leaf length

			//blob(di, di, hw, hw, le);//    /
			//blob(-(le + di), -(le + di), hw, hw, le);

			//blob(di, -(hw - 1), le, hw, hw); //  \
			//blob(-(le + di), -(hw - 1), le, hw, hw);

			//blob(-(hw - 1), di, hw, le, hw); //  |
			//blob(-(hw - 1), -(le + di), hw, le, hw);// |

			var cursor = new Point(0, 0);

			var sq32 = Math.sqrt(3) / 2;

			function getScreen(world) {
				var s = cellsize;
				var q = .95;

				return new Point(
					q * s * world.x * sq32,
					q * -s * (world.y - world.x / 2)
				);
			}

			var upleft = {};
			var up = {};
			var upright = {};
			var downleft = {};
			var down = {};
			var downright = {};

			var dirs = [up, upleft, downleft, down, downright, upright];

			var brush = stone;
			var oldbrush = brush;
		
		</script>
		
	<!-- user input -->
	<script type="text/javascript">

		function InputManager(mapping) {
			var $ = this;
			this.action = null;
			this.handler = function (event) { $.action = mapping[event.which] };

			window.addEventListener('keydown', this.handler, false);
		}

	</script>

	<!-- Bag -->
	<script type="text/javascript">
		function Bag(options) {
			this.numSets = 3;
			this.options = options;// array of arrays of arrays
			this.bag = [];
		}

		Bag.prototype.draw = function () {

			if (this.bag.length == 0) {
				// bag is empty generate new set of values
				for (var i = 0; i < this.numSets; ++i) {
					this.options = this.options.sort(function () { return rnd(3) - 1; });

					for (var j = 0; j < this.options.length; ++j) {
						this.bag.push(this.options[j].clone());
					}
				}
			}

			return this.bag.pop();
		};

	</script>

	<!-- Figure -->
	<script type="text/javascript">

		function Figure(id, points) {
			this.id = id;
			this.points = points;
		}

		Figure.prototype.clone = function () {
			return new Figure(this.id, this.points.map(function (p) { return [p[0], p[1]] }));
		}

		Figure.prototype.rotateCw = function () {
			return new Figure(this.id, this.points.map(function (p) { var x = p[0]; var y = p[1]; return [y, y - x]; }));
		}

		Figure.prototype.rotateCcw = function () {
			return new Figure(this.id, this.points.map(function (p) { var x = p[0]; var y = p[1]; return [x - y, x]; }));
		}

		function Block(pos, fig) {
			this.pos = pos;
			this.fig = fig;
		}
	</script>

	<!-- Tetris renderer -->
	<script type="text/javascript">

		function Adjustable() {
			this.k = 20;
			this.min = 0;
			this.max = .1;

			this.currentmin = null;
			this.currentmax = null;
			this.range = null;
		}

		Adjustable.prototype.scale = function (v) {
			this.max = Math.max(this.max, v);
			this.min = Math.min(this.min, v);

			if (this.currentmin == null)
				this.currentmin = this.min;

			if (this.currentmax == null)
				this.currentmax = this.max;

			this.range = this.currentmax - this.currentmin;

			return this.currentmax == this.currentmin ? 1 : (v - this.currentmin) / this.range;
		}

		Adjustable.prototype.adjust = function () {
			this.currentmax += (this.max - this.currentmax) / this.k;
			this.currentmin += (this.min - this.currentmin) / this.k;
		}

		function HextrisRenderer(ctx) {
			this.ctx = ctx;

			this.level = new Adjustable();
			this.type = new Adjustable();
		}

		var tau = 2 * Math.PI;
		HextrisRenderer.prototype.draw = function (store) {
			var $ = this;
			var ctx = this.ctx;

			function cellColor(cell) {
				if (cell.value != null) {
					var line = cell.pos.x > 0
						? cell.pos.y-cell.pos.x
						: cell.pos.y;

					var level = $.level.scale(line);

					if ('type' in cell.value) {
						var t = cell.value.type < 0 ? (-cell.value.type - 1)
							: cell.value.type;

						var type = $.type.scale(t + 1);
						var type = $.type.scale(t);

						var h = 360 * type;
						var s = (70 + 20 * (1 - level)) * (cell.value.type >= 0 ? 1 : 1.25);
						var l = (40 + 15 * (1 - level) * (1 - .5 * (line % 2))) * (cell.value.type >= 0 ? 1 : 1.25);
						var a = cell.value.type >= 0 ? 1 : .35;

						return 'hsla(' + h + ', ' + s + '%, ' + l + '%, '+a+')';
					}
					return 'hsla(0, 0%, 100%, '+(.4 - .2*level)+')';
				}
				return 'transparent';
			}

			function drawCell(cell) {
				var s = cellsize;
				var screen = getScreen(cell.pos);
				var x = screen.x;
				var y = screen.y;

				ctx.fillStyle = cellColor(cell);

				if ('type' in cell.value) {
					if (cell.value.type < 0) {
						ctx.beginPath();
						ctx.arc(x, y, s / 5, 0, tau);
						ctx.fill();
					}
					else {
						ctx.fillHex(x, y, s);
					}
				}
				else {
					var k = s / 10;
					var g = 3;

					ctx.fillRect(x, y, k, k);

				}

				ctx.restore();
			}

			ctx.clearRect(-ctx.canvas.width / 2, -ctx.canvas.height/2, ctx.canvas.width, ctx.canvas.height);
			store.each(drawCell);

			this.type.adjust();
			this.level.adjust();
		}


	</script>

	<!-- Tetris -->
	<script type="text/javascript">
		function HextrisController(actionSource, depth, breadth)
		{
			this.actionSource = actionSource;

			var depth = this.depth = 27;
			var breadth = this.breadth = 11;

			this.shape = new Pill(breadth, depth);

			var $ = this;
			this.preview = new Pill(5, 5);
			this.previewpos = new Point(breadth, breadth)

			var figs = [[[0, -1], [0, 0], [0, 1], [0, 2]],// line
				[[-2, 0], [-1, 0], [0, 0], [1, 1]],// bend, short-right
				[[-1, 0], [0, 0], [1, 1], [2, 2]],//   bend, short-left
				[[-1, -1], [0, 0], [0, 1], [1, 2]],//  "s"
				[[-1, 1], [0, 1], [0, 0], [1, 0]], //  "z"
				[[-1, -1], [0, -1], [1, 0], [1, 1]], //"u"
				[[-1, -1], [0, 0], [0, 1], [1, 0]],//  "y"
				[[-1, 0], [0, 0], [0, 1], [1, 0]], //  "p"
				[[-1, -1], [0, 0], [1, 1], [0, 1]], // "d"
				[[-1, 0], [0, 0], [0, 1], [1, 1]] //   "o"
			];

			var fid = 0;
			this.bag = new Bag(figs.map(function (points) { return new Figure(fid++, points); }));
			this.block = null;
			this.nextBlock = new Block(new Point(0, Math.floor(this.depth / 2) - 2), this.bag.draw());

			function offset(pointoffset) {
				return function (point) {
					return point.plus(pointoffset);
				}
			}

			this.store = new HexStore($.shape.extremes.concat($.preview.extremes.map(offset($.previewpos))), function (cell) {
				var x = cell.pos.x;
				var y = cell.pos.y;

				var line = Math.floor(depth / 2) + (x <= 0 ? y : y - x);

				return $.shape.contains(cell.pos) || $.preview.contains(cell.pos.plus(new Point(-$.previewpos.x, -$.previewpos.y)))
				? { level: line }
					: null;
			});


			this.dropCounter = 0;
			this.dropTolerance = 500; // should be based on speed
		}

		HextrisController.prototype.fetchNext = function () {
			this.unset(this.previewpos, this.nextBlock.fig);
			this.block = this.nextBlock;
			this.nextBlock = new Block(new Point(0, Math.floor(this.depth / 2) - 2), this.bag.draw());

			if (rnd(100) < 50) {
				this.nextBlock.fig = rnd(100) < 50
					? this.nextBlock.fig.rotateCw()
					: this.nextBlock.fig.rotateCcw()
			}

			this.set(this.previewpos, this.nextBlock.fig);

			if (!this.positionValid(this.block.pos, this.block.fig)) {
				this.gameOver();
			}
		}

		HextrisController.prototype.positionValid = function (pos, fig, okPos, okFig) {
			okPos = okPos || pos;
			okFig = okFig || { points: [] };
			var s = this.store;

			return fig.points.every(function (p) {

				var x = p[0] + pos.x;
				var y = p[1] + pos.y;
				var cell = s.get(new Point(x, y));

				function isOneOfOkCells(ok) {
					var okx = ok[0] + okPos.x;
					var oky = ok[1] + okPos.y;

					return okx == x && oky == y;
				}

				return cell != null      // cell exists
					&& (!('type' in cell) || cell.type < 0    // cell is unoccupied
						|| okFig.points.some(isOneOfOkCells));
			});
		}

		HextrisController.prototype.dropOne = function() {
			var nextPos = this.block.pos.plus(new Point(0, -1));

			if (!this.move(this.block.fig, nextPos)) {
				this.burn(this.block);

				this.block = null;
				this.shadow = null;
			}
		}
		
		HextrisController.prototype.burn = function (block) {

			var levels = [];
			var burn = [];

			var s = this.store;
			var p = this.shape;
			var w = Math.floor(this.breadth / 2);
			var h = Math.floor(this.depth / 2);

			function allset(line) {
				for (var x = -w; x <= w; ++x) {
					var y = x > 0 ? line + x : line;
					var cell = s.get(new Point(x, y));

					if (cell == null || !('type' in cell) || cell.type < 0) return false;
				}

				return true;
			}

			block.fig.points.forEach(function (p) {
				var x = p[0]+block.pos.x;
				var y = p[1]+block.pos.y;

				var line = x > 0
					? y - x
					: y;

				if (levels.indexOf(line) == -1) {
					levels.push(line);

					if (allset(line)) {
						burn.push(line);
					}
				}
			});

			if (burn.length > 0) {
				var start = burn.reduce(function(min, l) {
					return l < min ? l : min;
				}, Infinity);

				for (var line = start; line <= h; ++line) {
					// count how many lines to drop
					var fall = burn.reduce(function(num, ln) {
						return num + (ln <= line ? 1 : 0);
					}, 0);

					if (fall > 0) {
						for (var x = -w; x <= w; ++x) {
							var y = x > 0 ? line + x : line;
							var target = new Point(x, y);
							var source = new Point(x, y+fall);

							var vt = p.contains(target);
							var vs = p.contains(source);

							s.set(target, vt ? (vs ?s.get(source): {} ) : null);
							s.set(source, vs ? {} : null);
						}
					}
				}
			}
		}

		HextrisController.prototype.move = function (nextfig, nextpos) {
			if (nextfig != null && nextpos != null && this.positionValid(nextpos, nextfig, this.block.pos, this.block.fig)) {
				this.unset(this.block.pos, this.block.fig);
				if (this.shadow != null)
					this.unset(this.shadow.pos, this.shadow.fig);
				
				this.block.pos = nextpos;
				this.block.fig = nextfig;

				this.shadow = this.getShadow();
				this.shadowDistance = this.block.pos.y - this.shadow.pos.y;

				this.set(this.shadow.pos, this.shadow.fig);
				this.set(this.block.pos, this.block.fig);

				return true;
			}

			return false;
		}

		HextrisController.prototype.gameOver = function () {
			this.isGameOver = true;
			console.log('game over');
		}

		HextrisController.prototype.set = function (pos, fig)
		{
			var s = this.store;
			fig.points.forEach(function (p) {
				s.set(new Point(pos.x + p[0], pos.y + p[1]), { type: fig.id });
			});
		}

		HextrisController.prototype.unset = function (pos, fig) {
			var s = this.store;
			fig.points.forEach(function (p) {
				s.set(new Point(pos.x + p[0], pos.y + p[1]), {});
			});
		}

		HextrisController.prototype.getShadow = function () {

			var shadow = new Block(new Point(this.block.pos.x, this.block.pos.y), this.block.fig.clone());
			shadow.fig.id = -shadow.fig.id - 1;

			while (this.positionValid(shadow.pos, shadow.fig)) {
				shadow.pos.y--;
			}

			shadow.pos.y++;

			return shadow;
		}

		HextrisController.prototype.tick = function (delta) {
			if (!this.isGameOver) {
				if (this.block == null) {
					this.fetchNext();
					this.dropCounter = 0;

					if (!this.isGameOver)
						this.set(this.block.pos, this.block.fig);
				}
				else if ((this.dropCounter += delta) > this.dropTolerance) {
					this.dropOne();
					this.dropCounter -= this.dropTolerance;
				}
				else if (this.actionSource.action != null) {
					var nextfig = null;
					var nextpos = null;
					var resetdrop = false;

					switch (this.actionSource.action)
					{
						case HextrisController.rotateLeft:
							nextpos = this.block.pos;
							nextfig = this.block.fig.rotateCcw();
							break;

						case HextrisController.rotateRight:
							nextpos = this.block.pos;
							nextfig = this.block.fig.rotateCw();
							break;

						case HextrisController.left:
							nextpos = this.block.pos.plus(new Point(-1, -1));
							nextfig = this.block.fig;
							resetdrop = true;
							break;

						case HextrisController.right:
							nextpos = this.block.pos.plus(new Point(1, 0));
							nextfig = this.block.fig;
							resetdrop = true;
							break;

						case HextrisController.down:
							nextpos = this.block.pos;
							nextfig = this.block.fig;
							this.dropCounter = this.dropTolerance;
							break;

						case HextrisController.drop:
							nextpos = new Point(this.shadow.pos.x, this.shadow.pos.y);
							nextfig = this.block.fig;
							resetdrop = true;
							break;
					}

					if (this.move(nextfig, nextpos) && resetdrop) {
						this.dropCounter = 0;
					}

					this.actionSource.action = null;

				}
			}

			return this.store;
		}

		HextrisController.rotateLeft = {};
		HextrisController.rotateRight = {};
		HextrisController.left = {};
		HextrisController.drop = {};
		HextrisController.down = {};
		HextrisController.right = {};

		var im = new InputManager({
			103: HextrisController.rotateLeft,
			104: HextrisController.rotateRight,
			105: HextrisController.rotateRight,
			100: HextrisController.left,
			101: HextrisController.down,
			102: HextrisController.right,
			32: HextrisController.drop
		});

		var game = new HextrisController(im, 31, 13);
		var renderer = new HextrisRenderer(ctx);

		var lastTime = (new Date()).getTime();

		function frame() {
			var newTime = (new Date()).getTime();
			var delta = newTime - lastTime;
			lastTime = newTime;

			var store = game.tick(delta);

			if(store)
				renderer.draw(store);

			window.requestAnimationFrame(frame);
		}

		frame();
	</script>

	<!-- navigation -->
	<script type="text/javascript">

		var action = null;

		var left = {};
		var right = {};
		var toggle = {};

		var brush1 = {};
		var brush2 = {};
		var brush3 = {};
		var brush4 = {};
		var brush5 = {};

		function handleinput() {
			var donothing = false;

			var x = cursor.x;
			var y = cursor.y;

			switch (action) {
				case up:
					++y;
					break;
				case down:
					--y;
					break;
				case upleft:
					--x;
					break;
				case downright:
					++x;
					break;
				case upright:
					++x;
					++y;
					break;
				case downleft:
					--x;
					--y;
					break;
				case left:
					--x;
					y -= x & 1;
					break;
				case right:
					y += x & 1;
					++x;
					break;
				case brush1:
					oldbrush = brush;
					brush = stone;
					break;
				case brush2:
					oldbrush = brush;
					brush = raw;
					break;
				case brush3:
					oldbrush = brush;
					brush = polished;
					break;
				case brush4:
					oldbrush = brush;
					brush = door;
					break;
				case toggle:
					store.set(cursor, function (old) {
						return ("type" in old && old.type == brush)
							? { type: oldbrush }
							: { type: brush };
					});
					break;
				default:
					donothing = true;
					break;
			}

			if (!donothing) {
				cursor = new Point(x, y);
				draw();
				action = null;
			}
		}
		/*
		window.setInterval(handleinput, 50);

		
		window.addEventListener('keydown', function (e) {
			
			function key2action(event) {
				var map = {
					103: upleft,
					104: up,
					105: upright,
					100: downleft,
					101: down,
					102: downright,
					97: left,
					99: right,
					32: toggle,
					49: brush1,
					50: brush2,
					51: brush3,
					52: brush4,
					53: brush5,
				};

				return map[event.which];
			}

			action = key2action(e);

		}, false);
		*/
	</script>
</body>
</html>

