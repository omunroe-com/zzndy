<!DOCTYPE html>
<html>
<head>
    <title>Shoot</title>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>

    <link rel="stylesheet" href="../style/pixelless.css" type="text/css"/>

    <script type="text/javascript" src="../script/canvas.js"></script>
    <script type="text/javascript" src="script/shooter.js"></script>
</head>
<body>
<div id="container">
    <div class="content header">
	<h1>Shot</h1>
    </div>

    <div class="content">

            <canvas id="canvas" width="800px" height="500px"></canvas>

        <div class="empty_footer">
        </div>
    </div>
</div>
<div id="footer">
    <div class="content">
        &copy;
        <script type="text/javascript">
            var a = ['and', 'mail'].join('y@g');
            var b = ['<a ', 'href="mai', 'lto:zz',a, '.com?','subject=','JavaScript Filler', '"', '>Vynogradov<', '/a>'];
            document.write(b.join(''));
        </script>
        2009
    </div>
</div>
<script type="text/javascript">
	// Provide testing ground for different kind of shooting agents
	// with genetic agotirhm


var deg = Math.PI / 180;

function ShootersView(ctx, w, h)
{
	this.ctx = ctx;
	this.w = w;
	this.h = h;
	
	ctx.fillStyle = ctx.strokeStyle = '#eee';
	ctx.save().translate(w/2, h/2).scale(1, -1);
}

ShootersView.prototype.clear = function()
{
	ctx.clearRect(-this.w/2, -this.h/2, this.w, this.h);
}

ShootersView.prototype.render = function(s)
{
	if(s instanceof Shooter)
	{
		var size = 3.5;

		ctx.save()
			.translate(s.pos.x, s.pos.y)
			.rotate(s.mov.getDir() - Math.PI / 2)
			.beginPath()
			.moveTo(-size, -size)
			.lineTo(size, -size)
			.lineTo(0, 3*size)
			.closePath()
			.stroke()
			.restore();
	}
	else if(s instanceof Projectile)
	{
		if(s.dead)
		{
			ctx.save()
				.translate(s.pos.x, s.pos.y)
				.fillCircle(0, 0, 5*(3+s.dead))
				.restore();
		}
		else
		{
			ctx.save()
				.translate(s.pos.x, s.pos.y)
				.rotate(s.mov.getDir() - Math.PI / 2)
				.moveTo(0,0)
				.lineTo(0, 3)
				.stroke()
				.restore()
		}
	}
}

function Movable(pos, mov)
{
	this.pos = new Point(pos.x, pos.y);
	this.mov = new Vector(mov.x, mov.y);
}

Movable.prototype.advance = function()
{
	this.pos = this.pos.add(this.mov);
}

/**
 * @class Shooter
 *
 * @param {Point} pos - shooter initial position
 * @param {Vector} mov - movement vector
 * @param {Number} hp - health points
 * @param {Number} rate - rate of fire - time in milliseconds between shots
 * @param {Number} dam - projectile damage
 * @param {Number} speed - projectile speed
 * @param {Number} dist - projectile max distance
 * @param {Number} clip - clip size (in shots)
 * @param {Number} reload - reload time (milliseconds)
 * @param {Number} spread - projectiles released per shot
 */
function Shooter(pos, mov, hp, rate, dam, speed, dist, clip, reload, spread)
{
	if(pos instanceof Shooter)
	{
		Movable.call(this, pos.pos, pos.mov);

		this.hp = pos.hp;
		this.rate = pos.rate;
		this.dam = pos.dam;
		this.speed = pos.speed;
		this.dist = pos.dist;
		this.clip = pos.clip;
		this.reload = pos.reload;
		this.spread = pos.spread;
		this.lastShot = pos.lastShot;
	}
	else
	{
		Movable.call(this, pos, mov);

		this.hp = hp;
		this.rate = rate;
		this.dam = dam;
		this.speed = speed;
		this.dist = dist;
		this.clip = clip;
		this.reload = reload;
		this.spread = spread;

		this.lastShot = 0;
	}

	this.inClip = this.clip;
	this.reloading = false;

}

Shooter.prototype = new Movable(new Point(0, 0), new Vector(0, 0));
Shooter.prototype.base = Movable.prototype;

Shooter.prototype.steer = function(rad)
{
	var c = Math.cos(rad);
	var s = Math.sin(rad);
	var p = this.mov;

	this.mov = new Vector(p.x * c - p.y * s, p.y * c + p.x * s);
}

Shooter.prototype.readyToShoot = function(ts)
{
	var ok = false;
	if(this.reloading)
	{
		ok =  (ts - this.lastShot) > this.reload;
		if(ok){
			this.reloading = false;
			this.inClip = this.clip;
		}
	}
	else
	{
		ok = (ts - this.lastShot) >= this.rate;
	}

	return ok;
}

Shooter.prototype.shoot = function(ts)
{
	if(this.reloading)return [];
	if(--this.inClip == 0)
	{
		this.reloading = true;
	}

	this.lastShot = ts;
	return [new Projectile(this.pos, this.mov.norm().mul(this.speed), this.dam, this.dist)];
}

function ShooterArbiter(dflt, number)
{
	this.number = number;
	this.dflt = dflt;
	this.shooters = [];
	this.projectiles = [];

	var i=-1;
	while(++i<number)
	{
		var s = new Shooter(dflt);
		s.pos.x += Math.random() * 800 - 400; 
		s.pos.y += Math.random() * 500 - 250; 
		s.steer(Math.random() * Math.PI * 2);

		this.shooters.push(s);
	}
}

function Point(x, y)
{
	this.x = x;
	this.y = y;
}

Point.prototype.add = function(vec)
{
	return new Point(this.x + vec.x, this.y + vec.y);
}

Point.prototype.to = function(p)
{
	var dx = this.x - p.x;
	var dy = this.y - p.y;
	return Math.sqrt(dx*dx + dy*dy);
}

Point.prototype.toString = function()
{
	return ['(', this.x.toFixed(2), ', ', this.y.toFixed(2), ')'].join('');
}

function Vector(x, y)
{
	Point.call(this, x, y);
}

Vector.prototype = new Point;
Vector.prototype.base = Point.prototype;

Vector.prototype.getDir = function()
{
	return Math.atan2(this.y, this.x);
}

Vector.prototype.mul = function(num)
{
	return new Vector(this.x * num, this.y * num);
}

Vector.prototype.abs = function()
{
	return Math.sqrt(this.x*this.x + this.y*this.y);
}

Vector.prototype.norm = function()
{
	var d = this.abs();
	return new Vector(this.x / d, this.y / d);
}

function Projectile(pos, mov, dam, dist)
{
	Movable.call(this, pos, mov);
	this.maxDist = dist;
	this.dist = 0;
	this.dam = dam;
	this.dead = 0;
}

Projectile.prototype = new Movable(new Point(0, 0), new Vector(0, 0));
Projectile.prototype.base = Movable.prototype;

Projectile.prototype.advance = function()
{
	if(this.dead) return;

	var p1 = this.pos;
	this.base.advance.call(this);

	this.dist += p1.to(this.pos);

	if(this.dist >= this.maxDist) this.dead = 100;
}

function ShootersController(view, model)
{
	this.view = view;
	this.model = model;
	this.ts = 0;
}

ShootersController.prototype.frame = function()
{
	var ts = this.ts = (new Date()).getTime();
	var c = this;
	var ps = this.model.projectiles;

	this.model.shooters.forEach(function(s){
			s.advance();
			c.limit(s);
			if(Math.random() < .2)
				s.steer((Math.random() * 30 - 15)*deg);

			if(s.readyToShoot(ts))
			{
				s.shoot(ts).forEach(function(x){ps.push(x)});
			}
			});

	this.model.projectiles = ps.filter(function(p){
			p.advance();
			c.limit(p);
			if(p.dead) p.dead++;
			return p.dead <= 10;
			});
}

ShootersController.prototype.limit = function(s)
{
	if(s.pos.x < -400) s.pos.x = 400;
	if(s.pos.y < -250) s.pos.y = 250;
	if(s.pos.x > 400) s.pos.x = -400;
	if(s.pos.y > 250) s.pos.y = -250;
}

ShootersController.prototype.draw = function()
{
	var v = this.view;
	var s = this.model.shooters;
	var p = this.model.projectiles;

	window.setTimeout(function(){
			v.clear(); 
			p.forEach(v.render);
			s.forEach(v.render);
		}, 1);

}

var canvas = document.getElementById('canvas');
var ctx = canvas.getContext('2d');

var view = new ShootersView(ctx, 800, 500);

var numShooters = 4;
//function Shooter(pos, mov, hp, rate, dam, speed, dist, clip, reload, spread)
var deflt = new Shooter(new Point(0, 0), new Vector(2, 0), 100, 700, 20, 10, 500, 20, 3000, 1);
var arbiter = new ShooterArbiter(deflt, numShooters);

var ctrl = new ShootersController(view, arbiter);


function frame()
{
	ctrl.frame();
	ctrl.draw();
	
	window.setTimeout(frame, 50);
}

frame();


function trembl(val, pct)
{
		return val * ( 1 - 1 * pct + 1 * Math.random() * pct * 2 ) ;
}
/*

	var ctx = document.getElementById('canvas').getContext('2d');
	ctx.strokeStyle = '#eee';
	ctx.fillStyle = '#eee';

	var pos = new Point(400, 250);
	var vel = 2, rate = 600, dam = 10, speed = 8, pershot = 1, dist = 1000, clip = 20, reload = 1000;

	var deg = Math.PI / 180;

	var shooters = [];
	var proj = [];

	for(var i=0;i<10;++i)
		shooters.push(new  Shooter(pos, Math.PI * 2 * Math.random(), trembl(vel, .1), trembl(rate, .8), dam, trembl(speed, .1), pershot, dist, clip, reload));


	window.setInterval(function(){
				ctx.clearRect(0,0,800,500);
				shooters.forEach(move);
				shooters.forEach(render);
				proj = proj.filter(moveProj);
				proj.forEach(renderProj);
				}, 0);

	var frame = 0;
	function move(shooter)
{
		if(shooter.dead > 0)
		{
			if(shooter.dead > 10)
			{
					shooter.pos = pos;
					shooter.dead = 0;
			}
			else ++shooter.dead;
		}
			else
			{

		if(Math.random() < .5)
				shooter.dir += (Math.random() * 20 - 10) * deg;

		shooter.pos = shooter.pos.move(shooter.dir, shooter.vel);
		with(shooter.pos)
		{
				if(x>810)x=-10;
				if(x<-10)x=810;
				if(y>510)y=-10;
				if(y<-10)y=510;
		}

		if(shooter.toShoot(++frame))
		{
				var projectiles = shooter.shoot();
				for(var i=0;i<projectiles.length;++i)
						proj.push(projectiles[i]);
		}

		proj.forEach(function(p){

						var dx = p.x - shooter.pos.x;
						var dy = p.y - shooter.pos.y;
						var d = Math.sqrt(dx*dx + dy*dy);
						if(d<p.r){
						shooter.dead = 1;
						console.log(++p.shooter.score);
						}
						
						})
			}
	}

function moveProj(p)
{
		p.move();
			with(p)
		{
				if(x>810)x=-10;
				if(x<-10)x=810;
				if(y>510)y=-10;
				if(y<-10)y=510;
		}

		return p.dist > 0;
}

function renderProj(p)
{
		ctx.save()
				.translate(p.x, p.y)
				.rotate(p.dir)
				.moveTo(0,0)
				.lineTo(0, 3)
				.stroke()
				.restore();
}

	function render(shooter)
	{
		var s = 3.5;
		if(shooter.dead > 0)

ctx.save().translate(shooter.pos.x, shooter.pos.y).fillCircle(0, 0, 5*(3+shooter.dead)).restore();

		else

		ctx
				.save()
				.translate(shooter.pos.x, shooter.pos.y)
				.rotate(shooter.dir)
				.beginPath()
				.moveTo(-s, -s)
				.lineTo(s, -s)
				.lineTo(0, 3*s)
				.closePath()
				.stroke()
				.restore();
	}
*/
</script>
</body>
</html>
